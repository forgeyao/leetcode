// https://leetcode.cn/problems/number-of-islands/
package main

import "fmt"

/**
 * 从左到右、上到下遍历二维数组
 * 如果当前值不是'1',跳过
 * 如果为'1'，判断左和上是否为'0'，右和下是否没访问过，
 * 都是，则到找到一个岛的左上角，并相邻点逐步找到岛的全部
 *
 * 访问过的'1'会通过自增来标记已访问
 * 本质上就是广度优先搜索
 *
 * 时间 O(M*N), M 和 NN 分别为行数和列数
 * 空间 O(min(M,N)), 队列长度
 */
func numIslands(grid [][]byte) int {
	num := 0
	m, n := len(grid), len(grid[0])
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if grid[i][j] == '0' || grid[i][j] > '1' {
				continue
			}
			if (j == 0 || j > 0 && grid[i][j-1] == '0') &&
				(i == 0 || i > 0 && grid[i-1][j] == '0') &&
				(j == n-1 || j < n-1 && grid[i][j+1] <= '1') &&
				(i == m-1 || i < m-1 && grid[i+1][j] <= '1') {
				num++
				grid[i][j]++ // 大于'1'标记为已访问过
				visitIsland(i, j, grid)
			}
		}
	}

	return num
}

type pos struct {
	i, j int
}

func visitIsland(ii, jj int, grid [][]byte) {
	p := []pos{{ii, jj}} // 模拟栈
	m, n := len(grid), len(grid[0])
	for len(p) > 0 {
		i, j := p[0].i, p[0].j
		p = p[1:]
		if j > 0 && grid[i][j-1] == '1' {
			grid[i][j-1]++
			p = append(p, pos{i, j - 1})
		}
		if i > 0 && grid[i-1][j] == '1' {
			grid[i-1][j]++
			p = append(p, pos{i - 1, j})
		}
		if i < m-1 && grid[i+1][j] == '1' {
			grid[i+1][j]++
			p = append(p, pos{i + 1, j})
		}
		if j < n-1 && grid[i][j+1] == '1' {
			grid[i][j+1]++
			p = append(p, pos{i, j + 1})
		}
	}
}

func main() {
	grids := [][][]byte{
		{
			{'1', '1', '1', '1', '0'},
			{'1', '1', '0', '1', '0'},
			{'1', '1', '0', '0', '0'},
			{'0', '0', '0', '0', '0'},
		},
		{
			{'1', '1', '0', '0', '0'},
			{'1', '1', '0', '0', '0'},
			{'0', '0', '1', '0', '0'},
			{'0', '0', '0', '1', '1'},
		},
		{
			{'1', '1', '1'},
			{'0', '1', '0'},
			{'1', '1', '1'},
		},
		{
			{'1', '0', '1', '1', '1'},
			{'1', '0', '1', '0', '1'},
			{'1', '1', '1', '0', '1'},
		},
		{
			{'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '0', '1', '1'},
			{'0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '0'},
			{'1', '0', '1', '1', '1', '0', '0', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
			{'1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
			{'1', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
			{'1', '0', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1'},
			{'0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '1', '1', '1'},
			{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '1', '1'},
			{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
			{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
			{'0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
			{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
			{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
			{'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1'},
			{'1', '0', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '1', '0', '1', '1', '1'},
			{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '0'},
			{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0'},
			{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
			{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
			{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
		},
	}

	ans := []int{1, 3, 1, 1, 1}
	for i := 0; i < len(grids) && i < len(ans); i++ {
		fmt.Println(numIslands(grids[i]), "ans:", ans[i])
	}
}
